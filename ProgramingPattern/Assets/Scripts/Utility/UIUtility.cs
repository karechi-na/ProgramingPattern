
/// <summary>
/// UIユーティリティクラス
/// </summary>
public static class UIUtility
{
    /// <summary>
    /// 3桁ごとに「,」を挿入した文字列を生成するメソッド
    /// </summary>
    public static string NumberFormatter(int number)
    {
        // 3桁ごとにカンマを挿入
        // # は桁がない場合表示しない、0は桁がない場合0を表示する
        // , は3桁ごとに区切る
        return number.ToString("#,0");
    }

    /// <summary>
    /// 数値をパーセント表示に変換(少数第2位まで)するメソッド
    /// </summary>
    public static string ConvertPercent(float ratio)
    {
        // 受け取った引数を100倍する
        float convertRatio = ratio * 100.0f;

        // 四捨五入し少数第2位まで表示
        // F2 は少数第2位まで表示する書式指定子
        // 戻り値に「%」を付与して返す
        return convertRatio.ToString("F2") + "%";
    }
}

// UtilityClass
// 「状態を持たず、汎用的な処理をstaticメソッドとして提供するクラス」
// 
// 特徴
// ・インスタンス化しない
// ・すべてstatic
// ・状態を持たない
// 
// メリット
// 1. シンプルでわかりやすい
// 　　→呼び出しが直観的
//
// 2. 余計な設計が不要
// 　　→インスタンス管理不要
// 　　→小規模開発では特に有効
//
// 3. 再利用性が高い
// 　　→数値計算
// 　　→文字列整形
// 　　→日付変換
// 　　・純粋関数的処理に強い
//
// 4. パフォーマンス面で有利
// 　　→インスタンス生成なし
// 　　→GC負荷が低い
// 
// デメリット
// 1. 依存関係が見えない
// 　　→内部で使っていても外からはわからない
//
// 2. テストがしづらい
// 　　→振る舞い変更が困難
//
// 3. 責務が肥大化しやすい
// 　　CommonUtil
// 　　 |- string処理
// 　　 |- Date処理
// 　　 |- 暗号化
// 　　 |- ファイル操作
// 　　・なんでも屋クラスになりがち
//
// 4. 設計の逃げ道になりやすい
// 　　→「置き場所に困ったらUtil」
// 　　→本来ServiceやValueObjectであるべき処理が混入
// 
// 
// 
// 
// 
// 